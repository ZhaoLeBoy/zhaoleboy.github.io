---
layout:     post
title:      "1.构造可靠传输数据协议之GBN与SR"
subtitle:   "1.构造可靠传输数据协议之GBN与SR"
date:        2020-08-02
author:     "ZhaoLe"
# header-img: "img/redis/post-bg.png"
catalog: true
tags:
    - TCP/IP
---

### 构造可靠传输数据协议之GBN与SR
解决流水线(相当于同时发送多个分组)的差错恢复有两种基本方法 。

### GBN（Go-Back-N）回退N步

在GBN协议中，发送方将同时发送多个分组，分组数不能超过某个最大允许数N, N常被称为窗口长度，所以GBN也被称为滑动窗口协议(sliding-windows protocol) ，主要用于::流量控制::的，用两个序号将分组序号范围分成了4端。已被确认，发送未确认，可用未发送，不可用。
GBN是源自当出现丢失和时延过长的分组时`发送方`的行为。通过一个定时来记录最早的已发送但未确认分组的情况，如果发送方收到某个ACK，但仍有已发送但未确认的分组，定时器重新启动，如果没有了则停止该定时器。
下图例子： 窗口长度为4个分组，开始发送分组，一次性发送0-3号分组 ，如果想发送后续的分组，需要先等到0~3分组被全部确认后窗口才能滑动。在接受方这边，如果在发送分组2时丢失，则再后续接受的分组3，4，5 直接丢弃,重新返回最小确认号 (也就是ACK2)…

![1](/img/tcp/gbn_sr/1.png)

可以看出来GBK协议的策略很简单，是用了直接丢弃策略，即使是正确接受但乱序的分组，也不进行缓存，假如接收方期望接受分组n，结果接收到了n+1号分组，因为要保证数据按序交付，所以直接丢弃已经接收到包括n+1在内的后续所有分组。并且重新发送最近按序接受分组的ACK。直到超时触发，会重新发送分组n，如果正确接受后，继续发送后续的n+1,n+2….

GBN优缺点明显，接收方不用缓存已经接受的分组，选择直接丢弃。但是缺点是随后对该分组的重传也许会丢失或出错，因此甚至需要更多的重传，会出现带宽利用率下降。

### SR （Selective Repeat ）选择重传
由于GBN自身存在一些性能问题，如可能存在单个分组的差错会造成大量分组重传。带宽利用率会变的低下等问题，进而又出现了选择重传这种协议。
简单的说SR跟GBN不同的地方在于，它只会针对错误分组进行重发，避免不必要的重传。
因为是选择性重发，跟GBN比它会要求每个分组必须拥有自己的逻辑定时器。一般也可以用单个硬件定时器模拟多个逻辑定时器的操作。
SR协议在接收方也有个类似发送方的滑动窗口，并且接收方可以优先将正确接受的乱序分组先缓存起来，直到所有分组都全部接受为止，再一起交付给上层。

下图中发送方每发送出一个分组并且成功接收到了对应的ACK，则窗口向后移动一个位置，直到可发送窗口满了，就会暂时停止新的分组发送。
接收方窗口移动的方式跟发送方类似，当成功接收到对应的分组就会返回一个ACK并且窗口向后移动一个位置，不过会出现一种特殊情况，就是当成功接受某个分组 (例如分组1)，在返回ACK1的时候出现了错误，导致了ACK1没有返回到接收方，这个时候 接收方的窗口已经向右移动了一格。当发送发迟迟没有收到ACK1的反馈则会认为这个分组发送失败，等到超时到了分组1会重新发送，这个时候发送放任然会产生一个ACK1告知接收方，即使该分组是接收方以前已确认过的分组。

 ![2](/img/tcp/gbn_sr/2.png)
